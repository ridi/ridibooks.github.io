---
layout: blog_post
title: "DevOps 팀을 위한 모니터링 팁"
description: "개발과 운영을 동시에 하느라 고통받는 DevOps를 위한 모니터링 꿀팁"
header-img: "blog/img/bg-9.jpg"
date: 2016-05-22
author: namenu
category: engineering
published: true
---

다음 중 몇 개나 해당하시나요?

* 1~5명 규모의 작은 개발팀에서 일한다.
* DevOps 조직이다.
* 우여곡절 끝에 서비스는 런칭했지만, 개발과 동시에 운영을 해야하는 상황이다.
* 서버 인프라 지식이 별로 없다.
* 무중단 서비스 운영 경험이 별로 없다.
* 팀 내에 시스템 엔지니어(SE)와 데이터베이스 전문가(DBA)가 없다.

하나라도 해당한다면 이 글이 도움이 될 지도 모릅니다.

누구나 쉽고 빠르게 앱을 만들고 서비스를 런칭할 수 있는 시대가 되었지만 문제는 런칭 이후입니다. 런칭 이후에는 고객이 100명이라도 [안정적인(High Availability)](https://en.wikipedia.org/wiki/High_availability) 서비스를 운영해야 하는 것이 백엔드 개발자의 임무이기 때문입니다.

안정적인 서비스를 운영하기 위해서는 체계적인 모니터링 필수라고 하는데 그마저도 쉽지 않습니다. 가장 큰 문제는 (장애가 터지기 전까지) 무엇을 모니터링 해야 하는지조차 모른다는 것이고, 당장 개발해야할 것들이 산더미처럼 쌓여있는데 사람도 부족한 것도 문제입니다.

그렇지만 누군가는 해야하는 일입니다. 리디북스 역시 모니터링이 전혀 없던 시절이 있었으나, 크고 작은 실패와 좌절을 겪으며 조금씩 경험을 쌓아가고 있습니다. 이번 글에서는 우리가 모니터링과 관련하여 고민해 온 내용들을 소개해볼까 합니다.

---

# 어떻게 모니터링할 것인가

시스템의 안정성을 높이기 위해 투입해야 하는 노력은 지수적으로 증가합니다. 아래 표에서 보듯이 SLA 를 99.999% 에서 99.9999% 로 높이려고 한다면 1년에 약 5분의 가용시간을 얻을 뿐이지만 이를 위해 수백시간 이상의 노력을 들여야 합니다.

| 가용성    | 연간 장애 시간 | 주간 장애 시간 |
|:--------:|:-----------:|:-----------:|
| 99.995%  | 26.28 분    | 30.24 초    |
| 99.999%  | 5.26 분     | 6.05 초     |
| 99.9999% | 0.525 분    | 0.6048 초   |
{: .post-table }

완벽함을 추구하면 할 수록 얻을 수 있는 고객 만족은 미미한 것에 비해 이를 위한 개발자의 노력은 기하급수적으로 증가합니다. 따라서, 먼저 대응의 적정선을 찾고 효율적으로 움직이기 위한 계획을 세워야 합니다.

리디북스에서는 해야할 일을 4가지로 분류하여 중요한 일부터 처리하는 [아이젠하워 매트릭스](https://en.wikipedia.org/wiki/First_Things_First_(book))에서 그 대응 원칙을 차용하였는데, 그 이유는 시사하는 바가 동일하기 때문이었습니다.
즉, **중요한 것은 대부분 긴급하지 않고, 긴급한 것은 대체로 중요하지 않다는 점**입니다. 그리고 매트릭스의 두 축은 아래와 같습니다.

### 얼마나 급한가?

사무실의 무선 인터넷이 안된다면 서비스에 큰 문제는 아니지만, 당장 해결해야 하는 급한 일입니다. 반대로 백업 스크립트가 며칠째 동작하지 않아서 최근 데이터의 스냅샷이 없다면, 이는 당장 해결할 필요는 없겠지만 매우 중요한 일입니다.

그리고 장애란, 단순히 "고장"을 의미하는 것이 아니라 **서비스 이용에 지장이 없더라도 어떤 수치나 결과가 예상과 다른 상황**을 의미해야 합니다.
예를 들어, 웹서버의 평균 CPU 사용률이 70%가 넘는다거나 네트워크 대역폭을 90% 이상 사용하는 상황은 정상이 아닙니다. 조금만 트래픽이 몰려도 문제가 발생할 가능성이 매우 높기 때문에 잠재적인 장애로 간주해야 합니다.

우리는 급한 문제를 우선적으로 처리하는 경향이 있어서, 덜 급하지만 더 중요한 일을 놓치는 경우가 많습니다. 이를 피하려면 장애의 그 심각도에 따라서도 구분해야 합니다.


### 얼마나 심각한가?

심각도를 처음부터 너무 상세하게 구분할 필요는 없으며, 크게 서비스 이용에 치명적인 것과 그렇지 않은 것으로 나누어 생각하면 됩니다. “치명적”의 의미는 서비스마다 다를 수 있지만 대개 아래에 해당합니다.

* 사업에 지장을 초래한다.
* 고객을 잃는다.

만약 웹페이지의 로딩 속도가 매우 느려서 나쁜 이미지를 준다면 이 역시 치명적일 수 있습니다. 실제로 아마존에서는 로딩 속도가 100ms 지연될 때마다 눈에 띄는 매출 하락이 발생했다는 테스트 결과가 있습니다.
따라서 속도에 대한 매트릭을 모니터링 지표에 추가하는 것은 좋은 선택입니다.
 
이상을 토대로 장애 종류에 따른 대응 원칙을 정리하면 아래와 같습니다.

|    | 급함 | 안급함 |
|---:|:---:|:---:|
|**심각함** | ➀ 즉각 대응, 즉각 인지 | ➁ 평소 보완, 항상 경계 |
|**안심각함**| ➂ 빨리 대응, 최소 대응 | ➃ 대응하지 않기 |
{: .post-table }

이 중에서 항상 의식하고 놓치지 말아야 하는 것은 안급하지만 잠재적으로 심각한 장애(➁)입니다. 그리고 모니터링은 한 번 시작하게 되면 관리를 위한 비용이 꾸준히 투입되어야 하기 때문에 사소한 문제(➂, ➃)를 굳이 파헤치는 것은 오히려 독이 될 수도 있습니다.

모니터링 측면에서 본다면 발생중인 장애는 최대한 빨리 발견하는 것이 중요하며, 잠재적인 장애는 상태의 변화를 최대한 빨리 감지하는 것이 중요합니다. 예를 들어, 디스크의 여유공간은 완전히 바닥나기 전까지 어떠한 경고도 나타나지 않지만 부족한 상황이 발생하면 어떤 부작용이 생길지 예측할 수 없습니다.

---

# 필수 모니터링 갖추기

모니터링을 해야할 대상은 기술 스택과 코드 구현에 따라 달라지겠지만, 빼놓을 수 없는 것들이 몇 가지 있습니다. 리디북스에서는 서버의 프로비저닝과 동시에 아래 내용들을 함께 준비하고 있습니다.

## 1. 리소스 및 시스템 모니터링
 
각종 시스템 리소스 및 하드웨어 상태는 필수 모니터링 대상입니다. 모니터링 툴을 설치해보면 측정해주는 항목들이 너무 많아서 당황스러운 경험을 하게 되는데요. 그 중에서도 우리가 주목하고 있는 항목들은 아래와 같습니다.

- CPU Usage
- Load Average
- Disk Usage
- Disk Utilization (iowait, IOPS)
- Swap Memory Usage (사용시)
- Temperature (인프라 직접 구축시)
- RAID Status (인프라 직접 구축시)
- S.M.A.R.T Errors (인프라 직접 구축시)

이 중 몇가지는 [New Relic](https://newrelic.com/server-monitoring) 에서 무료로 지원하므로 당장 여력이 없다면 이를 이용하는 것도 좋은 방법입니다.

클라우드 환경이 아닌 데이터센터에서 인프라를 직접 구축하여 운영하고 있다면 좀 더 많은 노력이 필요합니다. 하드웨어적인 장애를 직접 신경써야 하기 때문입니다. 실제로 팬(fan)이 고장나거나 케이블이 환풍구를 막아서 서버의 온도가 비정상적으로 높아지다가 기기가 오동작하는 어처구니없는 상황도 발생합니다.

### Disk

서버 환경에서 SSD 사용이 점점 대세가 되어가고 있는데, 최근 [구글이 공개한 정보](http://www.zdnet.com/article/ssd-reliability-in-the-real-world-googles-experience/)에 따르면 SSD에서 배드블럭이 발생하는 일은 매우 흔하며, 시간이 오래될 수록 안정성이 떨어진다고 합니다.

따라서 디스크와 관련된 RAID나 S.M.A.R.T 오류는 가능한 빨리 대응해야 합니다. 특히 RAID 장비를 구성할 때에는 같은 공정에서 출하된 같은 벤더의 제품을 일괄적으로 구매해서 사용하기 때문에, 동일한 하드웨어 결함을 지니고 있거나 평균 수명도 비슷하므로 결코 안이하게 대응해서는 안됩니다.

리디북스에서는 전자책 원본을 보관하는 스토리지에서 4개의 사본(replica) 중 3개가 연달아 깨지는 끔찍한 사고를 경험한 이후로, 디스크 오류는 1순위로 대응하고 있습니다. 참고로 스토리지 서버를 구축한지 3년째가 되는 해였고, 모두 [S사의 제품](http://namu.wiki/w/Seagate#s-3.3)이었습니다.

iowait 은 CPU가 유휴(idle) 상태로 I/O를 대기하는 시간을 나타낸 수치입니다. 이를 통해 현재 시스템이 I/O 병목을 겪고 있는지 판단할 수 있기 때문에 중요합니다.
이 수치가 너무 높다면 블록 디바이스나 네트워크가 너무 느린 상황이거나 포화 상태일 수 있으므로, 더 높은 IOPS 장비로 업그레이드하거나 부하를 분산해야 합니다.

단, CPU 성능에 영향을 받는 수치이므로 고성능 CPU를 사용할수록 평균 iowait이 높게 측정됩니다. (따라서 성능을 평가하기 위한 지표로는 IOPS도 함께 분석해야 합니다.)


### Load Average

Load Average(평균 부하)는 마치 서버의 종합 성적표 같아서, 이 역시 주목할 필요가 있습니다. Load Average에 변동이 생긴다면 평소와는 다른 처리량(throughput)을 내고 있다는 뜻입니다. 요청량이 증가하여 수치가 올라갔다면 서버 증설과 튜닝에 대비해야 하지만, 그렇지 않다면 어딘가 병목이 발생하여 처리 효율이 낮아졌다는 신호입니다.

아직 Load Average를 모니터링하고 있지 않다면 주요 서버군부터 아래 규칙을 참고하여 초기 기준치를 설정하기를 권장합니다. 물론 어디까지나 초기 설정 값이며, 실제 상황에 적합하지 않을 수 있습니다.

> Warning Level : 0.7 * number of cores <br>
> Critical Level : 1.0 * number of cores


간혹 커널 자체에 문제가 있거나, 커널 모드에서 예외가 발생하는 경우에는 syslogd 데몬이 남기는 로그를 파악해야 합니다. [Papertrail](https://papertrailapp.com/
), [Splunk](https://www.splunk.com/), [Loggly](https://www.loggly.com/) 등의 서비스는 크리티컬 수준 이상의 syslog 에 대해 알림을 설정할 수 있을 뿐 아니라,
텍스트 형태로 남겨지는 모든 로그에 대한 관리를 쉽게 도와줍니다. 비록 유료지만 커널 모니터링 용으로만 사용한다면 비용이 많이 들지 않습니다.

 
## 2. 응용프로그램 모니터링

앱이나 서버에서 발생하는 크래시와 예외를 수집하는 도구 역시 장애 예방에 필수입니다. 해당 기능을 실시간으로 제공하는 다양한 서비스들이 존재하는데 많이 쓰이는 것으로는 [Sentry](https://www.getsentry.com/), [Rollbar](https://rollbar.com/), [Airbrake](https://airbrake.io/), [NewRelic APM](http://newreilc.com/application-monitoring) 등이 있습니다. 대부분 5분만에 설정이 가능한데다 어느것을 선택하더라도 핵심 기능에는 부족함이 없습니다.

단, 현재까지 가성비로는 Sentry가 제일 뛰어납니다. Python의 Flask와 Jinja의 개발자로 유명한 Armin Ronacher가 팀에 합류했기에 발전가능성 측면에서도 많은 기대가 됩니다.

![Sentry의 실시간 에러 대시보드](https://i.imgur.com/EQ216Mn.jpg){: data-action="zoom" }
<figcaption>Sentry의 실시간 에러 대시보드</figcaption>


## 3. 데이터베이스 모니터링

팀에 DBA가 있나요? 모든 서버 개발자들이 인덱스와 스토리지 엔진의 특징에 대해 잘 이해하고, DB를 능숙하게 다루나요? 그것도 아니라면 개발자들이 작성한 모든 스키마와 쿼리에 대한 검증 과정을 거치고 있나요? 만약 그렇지 않다면 슬로우쿼리 모니터링은 필수입니다.

우리가 서비스 초기에 겪은 문제의 대부분은 인덱스를 잘 다루지 못하거나 새로 도입한 ORM에 대한 이해도가 낮아서 발생한 문제였습니다. 그 중에서도 특정 쿼리가 너무 많은 I/O를 유발하던 것이 주된 원인이었으며, 작고 가벼운 쿼리가 너무 많이 호출되어 문제가 된 경우는 거의 없었습니다.

잘못 설계된 스키마나 쿼리는 평소에는 드러나지 않다가 사용자가 몰리기 시작하면 큰 부하를 발생시켜서 기어이 서비스를 마비시키곤 합니다. 문제가 커지기 전에 그 조짐을 감지할 수는 없을까, 고민 끝에 우리가 시도한 방법은 “2초 이상 수행되는 쿼리에 대해서 로그를 남기고, 초당 3개 이상 로그가 발생할 경우 알림”을 받도록 하는 것이었습니다.

MySQL에서는 아래 설정으로 로그를 활성화시킬 수 있습니다.

~~~ conf
[mysqld]
long_query_time=2  # 2초 이상 수행되는 쿼리에 대해서
slow_query_log=1   # 로그를 남겨주세요
~~~

쿼리 분석에는 Percona의 [pt-query-digest](https://www.percona.com/doc/percona-toolkit/2.2/pt-query-digest.html) 를 추천합니다. [VividCortext](https://www.vividcortex.com/monitoring/mysql/) 혹은 [MONyog](https://www.webyog.com/product/monyog) 등의 솔루션은 시각적으로 화려하고 실제로도 강력한 기능을 갖추고 있지만, 유료라는 큰 단점이 있습니다.

모니터링을 통해 알림을 받게 되면 문제가 더 커지기 전에 해당 기능을 수정하거나 중단시킬 기회가 생깁니다. 특히 새롭게 추가한 기능을 배포할 때 서비스가 불안해 질 수 있는데, 퍼포먼스 문제를 미리 발견하고 롤백을 서두를 수 있다는 것도 장점입니다.

물론 가장 이상적인 상황은 n초 이상 수행되는 쿼리를 모두 없애는 것입니다. 하지만 현실은 튜닝을 포기하고 테이블을 풀스캔하도록 두는게 나은 선택일 수 있으며, OLAP/ETL 인프라가 별도로 구축되어 있지 않은 상황에서는 어쩔 수 없이 슬로우쿼리가 발생하게 됩니다. 우리가 초당 로그 갯수로 판단을 하게된 것도 이러한 이유 때문이었습니다.

![슬로우쿼리 메일](https://i.imgur.com/iMeR94W.png){: data-action="zoom" }
<figcaption>자동으로 슬로우 쿼리를 받아보면 문제해결에 도움이 됩니다.</figcaption>


## 4. 배치 작업(scheduled task) 모니터링

매일 백업 스크립트를 돌리고는 있는데, 백업이 정상적으로 완료가 되었는지는 어떻게 판단하면 될까요? 에러는 위에서 설명한 도구들로 확인이 가능하겠지만 스크립트가 수행도중 멈춰버렸거나, 서버의 전원이 꺼졌다면?
게다가 크론 작업(crontab)이 수십개가 넘어가면 이를 수동으로 체크하는 것도 일이므로, 반드시 자동화해야 합니다.

이러한 상황에서 활용할 수 있는 유용한 도구가 [PushMon](http://www.pushmon.com/) 입니다.
PushMon은 정해진 시간에 ping을 보내지 않으면 이메일이나 SMS로 알림을 주는 서비스로, 원리는 매우 단순하나 없어서는 안될 기능을 "무료"로 제공합니다.

---


## 모니터링에 대응하기

모니터링을 효율적으로 하기 위한, 즉 서비스 안정성을 높이기 위한 핵심 원칙은 “필요한 인원이 필요한 알림만 받는것”입니다.

알림이 너무 많이 와서 음소거(Mute)를 하고 싶은 생각이 든다면 모니터링 체계에 문제가 있다는 신호입니다. 불필요하게 많은 경고는 안전 불감증을 낳을 뿐더러 정작 중요한 경고를 놓칠 확률을 높이기 때문입니다. 치명적인 알림은 모든 채널로 즉각 수신하고, 경고성 알림은 메일로 수신하되 정기 리포트나 메일함 자동분류 기능을 이용하여 중요한 정보를 놓치지 않는 습관이 중요합니다.

불필요하게 많은 인원이 알림을 받는 상황도 문제입니다. 알림 수신자를 늘리면 모니터링의 퀄리티가 높아질 것이라고 생각하지만 절대 그렇지 않습니다. 오히려 [방관자 효과](https://ko.wikipedia.org/wiki/%EB%B0%A9%EA%B4%80%EC%9E%90_%ED%9A%A8%EA%B3%BC)가 발생하여 아무도 알림에 대응하지 않는 상황이 발생하게 됩니다. 따라서 알림이 발생했을 때에는 1차, 2차 담당자를 사전에 지정하고 운영할 필요가 있습니다.

![방관자 효과의 적절한 예](https://i.imgur.com/0TBF9Dr.gif){: data-action="zoom" }
<figcaption>방관자 효과의 적절한 예</figcaption>

팀에서 [Slack](https://slack.com)을 사용한다면 기능 연동을 통해 실시간으로 이슈를 파악할 수 있고, 담당자 지정을 보다 쉽고 명확하게 할 수 있습니다. 특히, 별것 아닌 이모티콘(emoji) 만으로도 방관자 효과를 크게 줄일 수 있는데, 예를 들면 아래와 같습니다.

> 👀 - 확인중 <br>
> ✅ - 확인 완료 <br> 
> 😱 - 확인은 하였으나 나는 해결을 못하겠음

![Sentry를 Slack에 연동한 모습](https://i.imgur.com/54YxUPu.png){: .box-shadow data-action="zoom" }
<figcaption>Sentry를 Slack에 연동한 모습</figcaption>


또한, 모니터링 시스템에 대한 모니터링도 중요합니다. SaaS를 이용하는 경우에는 최악의 경우 해당 서비스의 점검기간에 대비할 수 없으며, 심지어는 점검중이라는 사실 조차 인지하지 못할 수 있습니다. 이에 대비하기 위해 리디북스에서는 [Server Density](https://www.serverdensity.com/monitor-monitoring/)로 모니터링을 모니터링하고 있습니다.


## 맺음말

장애를 얼마나 꼼꼼하게 예방하는지, 그리고 얼마나 즉각적으로 반응하는지는 팀 구성원의 실력으로 정해지는것이 아니라 팀의 문화와 원칙에 따라 정해집니다. 아직 팀에 뚜렷한 대응 원칙이 없다면 먼저 상황에 맞는 기준과 척도를 결정하고 공유해볼 것을 추천합니다.

무엇보다 DevOps를 수행하는 것은 사람임을 잊지 말아야 합니다. 인간은 99.99% 가용성이나 24/7 을 보장하지 못하며, Uptime은 하루도 되지 않습니다. 최근 DevOps가 대세가 되어가지만 Ops에서의 인간적인 측면은 진지하게 고려되지 않고 있습니다. 이러한 환경을 개선하기 위한 [HumanOps](http://www.humanops.com/)에 대한 소개와 함께 글을 마칩니다.

<br>

&nbsp;&nbsp;&nbsp;&nbsp; **HumanOps 계명**

1. 시스템을 만들고 고치는 것은 인간이다.
2. 인간은 지치고 스트레스를 받으며, 행복과 슬픔을 느낀다.
3. 시스템은 아직 감정이 없다. 오로지 SLA만 있다.
4. 인간은 스위치 온/오프 상태를 반복해야 한다.
5. 시스템을 운영하는 인간의 행복이 시스템의 안정성에 영향을 준다.
6. 빈번한 알림 == 인간의 피로
7. 최대한 자동화하고, 최후의 수단으로 인간에게 이관하라.
8. 문서화하고, 훈련하고, 시간을 아껴라.
9. 창피 주지 마라.
10. 인간의 문제는 시스템의 문제다.
11. 인간의 건강은 사업의 건강에 영향을 준다.
12. 인간 > 시스템
