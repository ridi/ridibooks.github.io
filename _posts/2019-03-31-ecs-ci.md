---
layout: blog_post
title: "리디셀렉트 AWS ECS 이전 후기"
description: "리디셀렉트 인프라를 AWS에 구축하는 과정에서 고민했던 것들을 공유합니다."
header-img: "blog/img/bg-1.jpg"
date: 2019-03-22
author: "kt.kang"
category: engineering
published: false
---

# 들어가며..
리디셀렉트는 빠르게 시장에 진출해야 했습니다. 그래서 인프라 구성에 들이는 시간을 아끼기 위해, 기존 리디북스에 덧붙여 개발했습니다.
덕분에 시간은 아낄 수 있었지만 그만큼 불필요한 의존이 생겼습니다.

그러다 이번에 의존을 제거하면서 AWS ECS에 새로 인프라를 구축했습니다.
그 과정에서 고민했던 것들을 공유드리며, ECS 도입을 고민하는 분들께 참고가 되었으면 합니다.


# ECS라고요? 요즘 쿠버네티스가 대세던데..
ECS는 사내 서비스 운영에 사용 중이었기 때문에 익숙했습니다.
하지만 시장의 대세가 되어가는 쿠버네티스도 도입해보고 싶었습니다. 도입한다면 새로운 인프라를 구축하는 지금이 좋은 기회였습니다.

결과적으로 아래 상황들을 고려해서 ECS를 선택했습니다.
- 인프라에서 AWS 플랫폼 비중이 높음
- 서비스 구조가 단순함
- 세밀한 컨테이너 설정이 필요하지 않음
- 가급적 1달 안에 작업을 완료해야 함

새 도구에 적응하기엔 주어진 시간이 부족했습니다. 팀이 새로운 경험을 쌓을 수 있는 좋은 기회였지만, 안정적인 서비스를 제공하는 것이 우선이었습니다.
게다가 아직은 복잡한 기능이 필요하지 않았습니다. 사용하지 않는 기능은 장애 포인트가 될 여지만 남기기 때문에 간단한 도구를 사용하는게 낫다고 판단했습니다.

사실 이전 과정에서 정말 어려웠던 것은 여러 팀에 걸쳐있는 비지니스 로직의 의존을 제거하는 일이었습니다.
이번에 서비스 의존을 제거하고 ECS에서 안정화된 다음에 컨테이너 관리 도구에 대해 고민해서 늦지 않을거라 생각했습니다.
당장은 서비스 코드를 안정적으로 분리하는 것에 집중하기로 했습니다.


# ECS matters? AWS matters!
ECS는 컨테이너 관리 도구입니다. 설정만 잘 해두면 컨테이너 배치, 실행 및 중지를 알아서 해줍니다.
하지만 자원 생성까지 ECS에서 다 해주진 않습니다. ECS는 컨트롤 타워 역할만 수행하며 자원을 생성하는 것은 다른 도구를 이용해야 합니다.

```

[그림] ECS 환경 구성 전반
- 클러스터링: VPC, EC2, ECR
- 서비스 검색: ALB, Route53
- 로깅 및 모니터링, 이벤트, 스케줄링: CloudWatch
- 권한: IAM
- 설정: SSM, KMS

```

이렇게 여러 도구를 조합해서 사용하는 형태다보니, 그만큼 관리도 분산되어 놓치기 쉽습니다. 관리에 소홀하면 나중에 다음과 같은 문제들을 겪을 수 있습니다.
- 불필요한 자원을 파악하기 힘듭니다. 쉽게 제거하지 못하고 불필요한 운영 비용이 누적됩니다.
- 과거에 변경한 내용이 나중에 장애를 유발한 경우, 내역을 모르면 대처하기 힘듭니다.
- 퇴사자 권한 정리가 제대로 되지 않으면 어느 순간 보안에 헛점이 생깁니다.

결국 ECS를 관리하는 일은 AWS 전반을 관리하는 일이 됩니다. 최대한 개발에 집중하기 위해 AWS 관리에 들이는 비용을 최소화하고 싶었습니다.


# Terraform으로 관리하기

문서를 잘 관리하려면 정말 많은 노력이 필요합니다.
- 누군가 문서를 갱신하는데 책임을 가지고, (그렇지 않으면 아무도 신경쓰지 않습니다.)
- 변경이 발생한 것을 인지해야 하고,
- 변경된 내역을 글로 풀어서 적어야 합니다.

다행히 요즘은 인프라 자동화 기술이 발전해서 코드를 통해 인프라를 관리할 수 있게 되었습니다. 특히 선언적 언어를 사용하면 코드와 인프라가 1:1로 대응되도록 할 수 있습니다.
코드를 보면 인프라 상태를 알 수 있으므로 문서로 설명되어야 할 내용이 많이 줄어듭니다.

저희는 선언적 언어를 사용하는 인프라 관리 도구인 Terraform을 도입했습니다. 사실 도입하고 나서 초반에는 일이 더 늘어난 느낌을 받았습니다.
HCL문법이 ~~못생겼고~~ 특이했고 state를 관리 방식을 체득하는데 시간이 필요했습니다. 팀원들이 거부감을 느꼈기 때문에 지속적인 설득이 필요했습니다.

지금은 잘 쓰이고 있으며 도입하길 잘했다고 생각합니다.
이전에는 문서나 스크립트를 따로 공들여 작성해야 했는데, 지금은 자연스럽게 인프라 운영 과정에서 작성한 코드가 그 역할을 하고 있습니다.

무엇보다 좋은 점은 개발자에게 익숙한 일이라는 점입니다. 알아서 저장소를 통해 변경 내역을 기록하고, 버전을 관리하며 리뷰도 진행합니다.
관리 대상은 변하지 않았자만 문서를 관리하던 때와는 다른 모습을 보였습니다.


# Terraform으로 관리하지 않는 것들
처음에는 모든 자원을 Terraform으로 구성했었는데, 지금은 일부를 제외시켰습니다.
일부 자원들은 Terraform 코드를 작성하는 수고를 들이면서까지 변경 내역을 관리할 필요가 없다고 판단했습니다. 조직마다 적합한 관리 방식은 다를 수 있으니 참고만 해주세요.

### 휘발성이 강한 자원
이런 자원들은 변경이 잦고 (예: 스케일 업/다운, 새 버전 배포), 서비스 도중 삭제될 수 있으므로 언제든 바로 생성할 수 있도록 만들었습니다.
문제가 생기면 보통 고치려고 하기 보단 새로 만들어 대처하기 때문에 변경 내역을 참고할 일이 거의 없습니다.
- ECS 서비스, ECS 작업
- CloudWatch 로그 그룹
- 오토스케일링 그룹에 속한 EC2 인스턴스

### 서비스 코드를 기반으로 생성되는 자원
서비스 코드와 자원이 1:1 대응하는 경우입니다. 서비스 코드 저장소에서 내역을 이미 관리하고 있으므로 Terraform을 통해 한번 더 관리할 필요는 없다고 판단했습니다.
(저희는 서비스 코드와 인프라 코드 저장소를 따로 관리하고 있습니다.)
- Lambda 함수
- ECS 작업 정의

```

[그림] Terraform으로 관리하는지, ecs-cli로 관리하는지로 구분한 전체 인프라 간략한 구성도

```
정리하면, ECS 외부 자원들과 ECS 클러스터까지만 Terraform으로 관리하기로 했습니다.
ECS 서비스와 작업 정의는 [ecs-cli](https://docs.aws.amazon.com/ko_kr/AmazonECS/latest/developerguide/ECS_CLI.html)로 관리합니다.
특히 `ecs-cli compose` 명령을 사용하면 ECS를 docker-compose를 사용하는 것처럼 관리할 수 있어서 편합니다.

# ECS 개선점들
이전 작업을 하면서 ECS 몇몇 기능들이 개선된 것을 알게 되었습니다.
덕분에 처음 ECS를 사용했을 때보다 수월하게 작업할 수 있었는데, 어떤 것들이 변경되었는지 짧게 정리해봤습니다.

### 환경 변수를 SSM으로부터 읽어오는 기능 추가[^1]
컨테이너 내부에 값을 전달해야 할 때 보통 환경변수를 이용합니다. ECS는 작업 정의를 만들 때 환경 변수를 지정하게 되어있어서 다소 불편했습니다.

- 실행 시점에 값을 읽어오려면 컨테이너 내부에서 (예: entry point) 변수를 읽도록 직접 구현해야 함
- 환경변수 값만 변경되어도 작업 정의 버전을 올려야 함
- 컨테이너 관리서비스를 사용하면서도 변수 관리 비용이 추가로 듬

우회법으로 [chamber](https://github.com/segmentio/chamber)를 사용하는 방법이 유명했습니다. chamber를 사용하면 변수를 AWS SSM에서 관리하고 필요할 때 컨테이너 내부로 가져올 수 있었습니다.

그런데 작년부터 ECS에서 바로 SSM 변수를 읽는 기능이 추가됐습니다. 이제 변수에 값대신 SSM 변수 주소를 지정할 수 있습니다. 이렇게 설정하면 ECS가 컨테이너를 실행할 때 알아서 지정된 SSM 변수값을 환경변수에 설정해줍니다.

### Route53를 연동하는 서비스 검색 기능 추가[^2]
서비스 검색을 구성하려면 ALB를 사용하거나 Consul과 같은 외부 도구를 직접 운영하는 수 밖에 없었습니다.
ALB를 사용하면 추가 비용이 들고 라우팅 룰을 관리하는 것이 번거롭습니다. 프록시 방식이므로 딜레이도 살짝 증가합니다. 그렇다고 외부 도구를 직접 운영하기는 너무 부담됩니다.

이제는 ECS 서비스에 Route53를 연동하면 간단히 해결됩니다. ECS 서비스에 관련 기능을 설정한 뒤 배포하면, Route53가 AWS 내부 DNS에 컨테이너 주소를 자동으로 등록해줍니다. 서비스명만 알면 컨테이너를 찾을 수 있습니다.

물론 공짜는 아닙니다. 네임스페이스를 생성할 때, 그리고 쿼리를 요청할 때 비용이 지불되지만, ALB에 비하면 적은 비용입니다. 사용도 쉬워서 이제 ECS도 서비스 검색을 구성하는 부담이 많이 줄었습니다.

### ALB 고정 응답 추가[^3], ALB 대상 그룹에 Lambda를 설정할 수 있도록 개선[^4]
사실 이 기능은 ECS가 아닌 ALB 업데이트입니다. 하지만 이 업데이트 덕분에 간단한 응답은 ECS 변경없이 구현할 수 있게 되었습니다. 이전에는 단순한 요청 처리도 ECS에 컨테이너를 추가해야 구현할 수 있었지만, 이제 302 응답 정도는 ALB에 바로 추가할 수 있게 되었습니다.

특별한 응답 헤더가 필요하거나, 5XX 응답을 보내야 하는 경우에는 고정 응답을 사용할 수 없습니다. 대신 Lambda를 ALB에 연결하면 됩니다. API Gateway 없이 ALB만 있어도 Lambda로 요청을 처리할 수 있게 되었습니다.

# 자동 배포 구성하기
컨테이너가 실행될 인프라가 완성되었으니 이제 자동 배포를 구성할 차례입니다.

AWS의 Code 시리즈(CodeDeploy, CodePipeline 등)는 일단 선택지에서 제외했습니다.
이미 ECS를 사용하며 어느정도 AWS 플랫폼에 종속된 상황에서 더이상 의존을 늘리고 싶지 않았습니다.
CI/CD는 외부 도구를 사용해도 문제될 부분이 없었습니다.

여러 선택지가 있지만 저희는 GitLab을 사용하기로 했습니다. GitLab은 코드 저장소와 CI가 잘 통합되어 있기 때문에 각각 관리하는 것보다 사용하기 편리했습니다.
그리고 비공개 저장소를 무료로 무제한 제공한다는 점도 소소하지만 마음에 들었습니다.

# GitLab CI와 Terraform
GitLab CI는 Terraform용 배포 파이프라인을 만들 때 필요한 기능을 지원하고 있습니다. 이 점도 GitLab을 선택하게된 이유였습니다.

### `when: manual` 옵션
Terraform은 크게 init - plan - apply 로 이어지는 작업 흐름을 가지고 있습니다.

```

[그림] Terraform workflow

```

plan은 apply로 실제 인프라를 변경하기 전에 변경될 내역을 계산해서 미리 알려줍니다. 인프라가 잘못 변경되면 정말 복구하기 힘든 장애가 발생할 수 있기 때문에, 반드시 plan 결과를 검토하고 apply를 진행해야 합니다.
그래서 CI에 중간에 잠시 진행을 멈추고, 선택적으로 재진행시킬 수 있는 기능이 필요했습니다.

GitLab은 여기에 적합한 [Manual actions](https://docs.gitlab.com/ee/ci/yaml/#whenmanual)라는 기능을 가지고 있습니다. 파이프라인 잡에 `when: manual` 옵션을 설정하면 일단 진행을 멈추고 수동으로 재진행시키기 전까지 대기합니다.

```

[그림] when:manual 적용한 CI 파이프라인

```

Terraform의 경우 apply를 실행할 때 설정하면 됩니다. 그러면 plan이 끝난 뒤 apply에서 진행을 멈추는데, plan 결과를 확인해서 이상이 없는 경우에만 대기 중인 apply를 진행시키면 됩니다.

### `only:changes/except:changes` 옵션
이 기능은 CI 시작 조건을 설정하기 위한 옵션 중 하나입니다. git push 이벤트가 발생했을 때 지정한 파일들의 변경 여부를 체크해서 CI를 진행할지/말지를 설정할 수 있습니다.

이 옵션이 Terraform 관련해서 유용한 경우는 한 프로젝트에 여러 state를 관리하는 경우입니다.
이 기능이 없으면 git push 이벤트가 발생 시 어떤 state에 영향을 줄 지 알 수 없기 때문에, 무조건 모든 state들에 대해 init-plan-apply를 진행하는 전략을 사용해야 합니다.
관리하는 state가 늘어날수록 CI 진행이 느려지는 문제가 있습니다.

```

[그림] only:changes 옵션 적용하지 않은 경우 진행 설명

```

changes 옵션을 사용하면 git push 이벤트가 영향을 주는 state만 골라서 CI를 진행할 수 있습니다.
각 state마다 CI를 따로 구성하고 changes 옵션으로 자기 state와 관련된 파일들을 지정합니다.
이렇게하면 push 이벤트 발생 시 CI마다 지정된 파일들을 체크하는 과정에서 변경이 발생한 state만 골라지고, 필요한만큼만 init-plan-apply를 수행하게 됩니다.

```

[그림] only:changes 옵션 적용한 경우 진행 설명

```

### .gitlab-ci.yml 예시
다음은 Terraform 프로젝트의 .gitlab-ci.yml파일 예시입니다.
```

[그림] Terraform 프로젝트 .gitlab-ci.yml 예시

주석으로 아래 내용 설명
- job stage 설정하기
- automated에 필요한 환경 변수 설정 (아웃풋 최소화)
- cache 설정
- 다수의 runner를 사용할때 필요한 artifact 설정

```


# 결론
작성중..

---
[^1]: [https://aws.amazon.com/ko/about-aws/whats-new/2018/11/aws-launches-secrets-support-for-amazon-elastic-container-servic/](https://aws.amazon.com/ko/about-aws/whats-new/2018/11/aws-launches-secrets-support-for-amazon-elastic-container-servic/)
[^2]: [https://aws.amazon.com/ko/blogs/korea/amazon-ecs-service-discovery/](https://aws.amazon.com/ko/blogs/korea/amazon-ecs-service-discovery/) 링크에는 미국과 EU에서만 사용가능하다고 되어있으나, 9월부터 서울도 지원합니다.
[^3]: [https://aws.amazon.com/ko/about-aws/whats-new/2018/07/elastic-load-balancing-announces-support-for-redirects-and-fixed-responses-for-application-load-balancer/](https://aws.amazon.com/ko/about-aws/whats-new/2018/07/elastic-load-balancing-announces-support-for-redirects-and-fixed-responses-for-application-load-balancer/)
[^4]: [https://aws.amazon.com/ko/about-aws/whats-new/2018/11/alb-can-now-invoke-lambda-functions-to-serve-https-requests/](https://aws.amazon.com/ko/about-aws/whats-new/2018/11/alb-can-now-invoke-lambda-functions-to-serve-https-requests/)
