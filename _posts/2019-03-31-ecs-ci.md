---
layout: blog_post
title: "리디셀렉트 AWS ECS 이전 후기"
description: "리디셀렉트 인프라를 AWS에 구축하는 과정에서 고민했던 것들을 공유합니다."
header-img: "blog/img/bg-1.jpg"
date: 2019-03-22
author: "kt.kang"
category: engineering
published: false
---

# 들어가며..
리디셀렉트는 빠르게 시장에 진출해야 했습니다. 그래서 인프라 구성에 들이는 시간을 아끼기 위해, 기존 리디북스에 덧붙여 개발했습니다.
덕분에 시간은 아낄 수 있었지만 그만큼 불필요한 의존이 생겼습니다.

그러다 이번에 의존을 제거하면서 AWS ECS에 새로 인프라를 구축했습니다.
그 과정에서 고민했던 것들을 공유드리며, ECS 도입을 고민하는 분들께 참고가 되었으면 합니다.


# ECS라고요? 요즘 쿠버네티스가 대세던데..
저희는 아래 상황들을 고려해서 ECS를 선택했습니다.
- 이미 사내 서비스 운영에 사용하고 있어서 익숙함
- 인프라에서 AWS 플랫폼 비중이 높음
- 서비스 구조가 단순함
- 세밀한 컨테이너 설정이 필요하지 않음
- 가급적 1달 안에 작업을 완료해야 함

시장에서 쿠버네티스가 많이 쓰이는 추세라 이번 기회에 도입해보고 싶었습니다. 하지만 새 도구에 적응하기까지 주어진 시간이 충분하지 않다고 판단했습니다.
그리고 아직 서비스 구조가 단순해서 간단한 도구를 사용하는게 낫다고 생각했습니다. 제공하는 기능이 적으면 장애가 발생할 여지도 줄어듭니다.


# ECS matters? AWS matters!
컨테이너를 관리하기 위해선 여러가지 종류의 AWS 자원이 필요합니다.
그리고 이 모든 자원들을 ECS 한 곳에서 관리할 수는 없습니다.

```

[그림] ECS 환경 구성 전반
- 클러스터링: VPC, EC2, ECR
- 서비스 검색: ALB, Route53
- 로깅 및 모니터링, 이벤트, 스케줄링: CloudWatch
- 권한: IAM
- 설정: SSM, KMS

```

ECS를 운영하기 위해선 AWS 전반을 관리해야 합니다. 하지만 AWS 관리에 너무 많은 신경을 쏟고 싶지 않았습니다.
그렇다고 느슨하게 관리하다가 장애가 발생하거나 불필요한 운영 비용이 지출되는 것은 막고 싶었습니다.


# Terraform으로 관리하기
문서로 무언가를 관리하려면 정말 많은 노력이 필요하다는 것을 잘 알고 있었습니다.
- 누군가 문서를 갱신하는데 책임을 가지고, (그렇지 않으면 아무도 신경쓰지 않습니다.)
- 변경이 발생한 것을 인지해야 하고,
- 변경된 내역을 글로 풀어서 적어야 합니다.

그래서 요즘 각광받는 인프라 관리 도구인 Terraform을 도입해봤습니다.
Terraform은 선언적 언어를 사용해서 인프라 명세를 기술하고 운영에도 사용합니다.
작성된 코드를 보면 인프라 상태를 알 수 있어서 따로 문서를 만들어 인프라 상태를 기술할 필요가 없어졌습니다.

```
HCL 코드 예제
```

사실 도입하고 나서 초반에는 일이 더 늘어난 느낌을 받았습니다.
HCL문법이 ~~못생겼고~~ 특이했고 상태를 익숙하게 관리하기까지 적응 기간이 필요했습니다.
이런 부분에서 불편을 토로하는 팀원들을 지속적으로 설득할 필요가 있었습니다.

어느 정도 적응된 현재는 팀에서 잘 쓰고 있습니다.
코드로 표현하기 힘든 사업적 배경 등은 여전히 문서로 기록하고 있지만, 자주 변경이 발생하는 방화벽이나 권한, 각종 수치들은 Terraform 코드만으로 쉽게 파악할 수 있게 되었습니다.

무엇보다 좋았던 점은 개발자가 늘상 해오던 코드 관리 노하우를 그대로 활용할 수 있다는 점이었습니다.
강제하지 않아도 자연스럽게 저장소에 기록하고 버전을 관리하며 리뷰도 진행했습니다.
관리 대상은 동일하지만 문서를 관리할 때와 다른 모습을 보이는 것이 인상깊었습니다.


# Terraform으로 관리하지 않는 것들
일부 자원들의 경우 코드를 작성하는 수고를 들이면서까지 Terraform으로 관리할 필요가 없다고 판단했습니다.
조직마다 적합한 관리 방식은 다를 수 있으니 참고만 해주세요.

### 휘발성이 강한 자원
이런 자원들은 변경이 잦고 (예: 스케일 업/다운, 새 버전 배포), 서비스 도중 삭제될 수 있으므로 언제든 바로 생성할 수 있도록 만들었습니다.
문제가 생기면 보통 고치려고 하기 보단 새로 만들어 대처하기 때문에 변경 내역을 참고할 일이 거의 없습니다.
- ECS 서비스, ECS 작업
- CloudWatch 로그 그룹
- 오토스케일링 그룹에 속한 EC2 인스턴스

### 서비스 코드를 기반으로 생성되는 자원
서비스 코드와 자원이 1:1 대응하는 경우입니다. 서비스 코드 저장소에서 내역을 이미 관리하고 있으므로 Terraform을 통해 한번 더 관리할 필요는 없다고 판단했습니다.
(저희는 서비스 코드와 인프라 코드 저장소를 따로 관리하고 있습니다.)
- Lambda 함수
- ECS 작업 정의

```

[그림] Terraform으로 관리하는지, ecs-cli로 관리하는지로 구분한 전체 인프라 간략한 구성도

```
정리하면, ECS 외부 자원들과 ECS 클러스터까지만 Terraform으로 관리하기로 했습니다.
ECS 서비스와 작업 정의는 [ecs-cli](https://docs.aws.amazon.com/ko_kr/AmazonECS/latest/developerguide/ECS_CLI.html)로 관리합니다.
특히 `ecs-cli compose` 명령을 사용하면 ECS를 docker-compose를 사용하는 것처럼 관리할 수 있어서 편합니다.


# ECS 개선점들
이전 작업을 하면서 ECS 몇몇 기능들이 개선된 것을 알게 되었습니다.
덕분에 처음 ECS를 사용했을 때보다 수월하게 작업할 수 있었는데, 어떤 것들이 변경되었는지 짧게 정리해봤습니다.

### 환경 변수를 SSM으로부터 읽어오는 기능 추가[^1]
컨테이너 내부에 값을 전달해야 할 때 보통 환경변수를 이용합니다. ECS는 작업 정의를 만들 때 환경 변수를 지정하게 되어있어서 다소 불편했습니다.

- 실행 시점에 값을 읽어오려면 컨테이너 내부에서 (예: entry point) 변수를 읽도록 직접 구현해야 함
- 환경변수 값만 변경되어도 작업 정의 버전을 올려야 함
- 컨테이너 관리서비스를 사용하면서도 변수 관리 비용이 추가로 듬

우회법으로 [chamber](https://github.com/segmentio/chamber)를 사용하는 방법이 유명했습니다. chamber를 사용하면 변수를 AWS SSM에서 관리하고 필요할 때 컨테이너 내부로 가져올 수 있었습니다.

그런데 작년부터 ECS에서 바로 SSM 변수를 읽는 기능이 추가됐습니다. 이제 변수에 값대신 SSM 변수 주소를 지정할 수 있습니다. 이렇게 설정하면 ECS가 컨테이너를 실행할 때 알아서 지정된 SSM 변수값을 환경변수에 설정해줍니다.

### Route53를 연동하는 서비스 검색 기능 추가[^2]
서비스 검색을 구성하려면 ALB를 사용하거나 Consul과 같은 외부 도구를 직접 운영하는 수 밖에 없었습니다.
ALB를 사용하면 추가 비용이 들고 라우팅 룰을 관리하는 것이 번거롭습니다. 프록시 방식이므로 딜레이도 살짝 증가합니다. 그렇다고 외부 도구를 직접 운영하기는 너무 부담됩니다.

이제는 ECS 서비스에 Route53를 연동하면 간단히 해결됩니다. ECS 서비스에 관련 기능을 설정한 뒤 배포하면, Route53가 AWS 내부 DNS에 컨테이너 주소를 자동으로 등록해줍니다. 서비스명만 알면 컨테이너를 찾을 수 있습니다.

물론 공짜는 아닙니다. 네임스페이스를 생성할 때, 그리고 쿼리를 요청할 때 비용이 지불되지만, ALB에 비하면 적은 비용입니다. 사용도 쉬워서 이제 ECS도 서비스 검색을 구성하는 부담이 많이 줄었습니다.

### ALB 고정 응답 추가[^3], ALB 대상 그룹에 Lambda를 설정할 수 있도록 개선[^4]
사실 이 기능은 ECS가 아닌 ALB 업데이트입니다. 하지만 이 업데이트 덕분에 간단한 응답은 ECS 변경없이 구현할 수 있게 되었습니다. 이전에는 단순한 요청 처리도 ECS에 컨테이너를 추가해야 구현할 수 있었지만, 이제 302 응답 정도는 ALB에 바로 추가할 수 있게 되었습니다.

특별한 응답 헤더가 필요하거나, 5XX 응답을 보내야 하는 경우에는 고정 응답을 사용할 수 없습니다. 대신 Lambda를 ALB에 연결하면 됩니다. API Gateway 없이 ALB만 있어도 Lambda로 요청을 처리할 수 있게 되었습니다.


# GitLab CI와 Terraform
컨테이너가 실행될 인프라가 완성되었으니 이제 자동 배포를 구성할 차례입니다.

AWS의 Code 시리즈(CodeDeploy, CodePipeline 등)는 고려하지 않기로 했습니다.
이미 어느정도 AWS 플랫폼에 종속된 상황에서 더이상 의존을 늘리고 싶지 않았습니다.

GitHub과 GitLab 중 고민하다가 아래 이유로 GitLab을 선택했습니다.
- 코드 저장소와 CI가 잘 통합되어 있어 관리가 편함
- 비공개 저장소를 무료로 무제한 제공
- CI가 Terraform 배포 파이프라인을 만들 때 필요한 기능을 지원

# Terraform과 함께 사용하기 좋은 GitLab CI 옵션들

### `when: manual`
Terraform은 크게 init - plan - apply 로 이어지는 작업 흐름을 가지고 있습니다.

```

[그림] Terraform workflow

```

plan은 apply로 실제 인프라를 변경하기 전에 변경될 내역을 계산해서 미리 알려줍니다.
인프라가 잘못 변경되면 정말 복구하기 힘든 장애가 발생할 수 있기 때문에, 반드시 plan 결과를 검토하고 apply를 진행해야 합니다.

GitLab은 여기에 적합한 [Manual actions](https://docs.gitlab.com/ee/ci/yaml/#whenmanual)라는 기능을 가지고 있습니다.
`when: manual` 옵션을 설정하면 일단 진행을 멈추고 수동으로 재진행시키기 전까지 대기합니다.

```

[그림] when:manual 적용한 CI 파이프라인

```

Terraform의 경우 apply를 실행할 때 설정하면 됩니다. 그러면 apply에서 진행을 멈추는데, plan 결과를 확인해서 이상이 없는 경우에만 apply를 재진행시키면 됩니다.

### `only:changes`
이 기능은 파일을 기반으로 CI 시작 조건을 설정합니다. git push 이벤트가 발생했을 때 지정한 파일들이 변경되었을 때만 CI를 진행합니다.

이 옵션이 Terraform 관련해서 유용한 경우는 한 프로젝트에 여러 Terraform state를 관리하는 경우입니다.
옵션이 없으면 git push 이벤트가 발생 시 어떤 state를 변경했는지 알 수 없기 때문에, 모든 state들에 대해 init-plan-apply를 진행해야 합니다.
`only:changes`를 설정하면 변경한 state만 진행하기 때문에 CI 진행 시간을 단축시킬 수 있습니다.

```

[그림] only:changes 옵션 적용하지 않은 경우와 적용한 경우 설명

```

### .gitlab-ci.yml 예시
다음은 Terraform 프로젝트의 .gitlab-ci.yml파일 예시입니다.
```

[그림] Terraform 프로젝트 .gitlab-ci.yml 예시

주석으로 아래 내용 설명
- job stage 설정하기
- automated에 필요한 환경 변수 설정 (아웃풋 최소화)
- cache 설정
- 다수의 runner를 사용할때 필요한 artifact 설정

```


# 결론
작성중..

---
[^1]: [https://aws.amazon.com/ko/about-aws/whats-new/2018/11/aws-launches-secrets-support-for-amazon-elastic-container-servic/](https://aws.amazon.com/ko/about-aws/whats-new/2018/11/aws-launches-secrets-support-for-amazon-elastic-container-servic/)
[^2]: [https://aws.amazon.com/ko/blogs/korea/amazon-ecs-service-discovery/](https://aws.amazon.com/ko/blogs/korea/amazon-ecs-service-discovery/) 링크에는 미국과 EU에서만 사용가능하다고 되어있으나, 9월부터 서울도 지원합니다.
[^3]: [https://aws.amazon.com/ko/about-aws/whats-new/2018/07/elastic-load-balancing-announces-support-for-redirects-and-fixed-responses-for-application-load-balancer/](https://aws.amazon.com/ko/about-aws/whats-new/2018/07/elastic-load-balancing-announces-support-for-redirects-and-fixed-responses-for-application-load-balancer/)
[^4]: [https://aws.amazon.com/ko/about-aws/whats-new/2018/11/alb-can-now-invoke-lambda-functions-to-serve-https-requests/](https://aws.amazon.com/ko/about-aws/whats-new/2018/11/alb-can-now-invoke-lambda-functions-to-serve-https-requests/)
